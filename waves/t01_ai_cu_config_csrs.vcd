$date
	Thu Jul 24 14:53:44 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1us
$end
$scope module t01_ai_cu_config_csrs_tb $end
$var wire 4 ! stride [3:0] $end
$var wire 1 " relu_en $end
$var wire 32 # rdata [31:0] $end
$var wire 1 $ pool_en $end
$var wire 16 % out_ch [15:0] $end
$var wire 4 & layer_type [3:0] $end
$var wire 4 ' kernel_size [3:0] $end
$var wire 16 ( in_width [15:0] $end
$var wire 16 ) in_height [15:0] $end
$var wire 16 * in_ch [15:0] $end
$var wire 32 + addr_wgt_base [31:0] $end
$var wire 32 , addr_ofm_base [31:0] $end
$var wire 32 - addr_ifm_base [31:0] $end
$var parameter 32 . ADDR_WIDTH $end
$var parameter 32 / DATA_WIDTH $end
$var reg 6 0 addr [5:0] $end
$var reg 1 1 clk $end
$var reg 1 2 cs $end
$var reg 1 3 rst $end
$var reg 32 4 wdata [31:0] $end
$var reg 1 5 we $end
$scope module cu_config $end
$var wire 6 6 addr [5:0] $end
$var wire 1 1 clk $end
$var wire 1 2 cs $end
$var wire 1 3 rst $end
$var wire 1 7 valid $end
$var wire 32 8 wdata [31:0] $end
$var wire 1 5 we $end
$var wire 4 9 stride [3:0] $end
$var wire 1 " relu_en $end
$var wire 1 $ pool_en $end
$var wire 16 : out_ch [15:0] $end
$var wire 4 ; layer_type [3:0] $end
$var wire 4 < kernel_size [3:0] $end
$var wire 16 = in_width [15:0] $end
$var wire 16 > in_height [15:0] $end
$var wire 16 ? in_ch [15:0] $end
$var wire 32 @ addr_wgt_base [31:0] $end
$var wire 32 A addr_ofm_base [31:0] $end
$var wire 32 B addr_ifm_base [31:0] $end
$var parameter 32 C ADDR_WIDTH $end
$var parameter 32 D DATA_WIDTH $end
$var parameter 32 E REG_COUNT $end
$var reg 32 F rdata [31:0] $end
$var reg 512 G regs [511:0] $end
$upscope $end
$scope begin $ivl_for_loop0 $end
$var integer 32 H i [31:0] $end
$scope begin $ivl_for_loop1 $end
$var integer 32 I j [31:0] $end
$upscope $end
$upscope $end
$scope task tog_rst $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b10000 E
b100000 D
b110 C
b100000 /
b110 .
$end
#0
$dumpvars
b0 I
b0 H
b0 G
b0 F
b0 B
b0 A
b0 @
b0 ?
b0 >
b0 =
b0 <
b0 ;
b0 :
b0 9
b100001111101100110011011111001 8
x7
b100011 6
x5
b100001111101100110011011111001 4
13
x2
01
b100011 0
b0 -
b0 ,
b0 +
b0 *
b0 )
b0 (
b0 '
b0 &
b0 %
0$
b0 #
0"
b0 !
$end
#1000
11
#2000
01
12
b1 I
b1 H
03
#3000
11
#4000
17
b1000011111011001100110111110010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 G
01
15
#5000
11
#6000
01
b0 I
#7000
11
#8000
07
b0 G
01
05
#9000
11
#10000
01
02
b0 H
b1 I
#11000
11
#12000
01
15
#13000
11
#14000
01
b0 I
#15000
11
#16000
01
05
#17000
11
#18000
01
b11111111111111111111111111111111 H
b11111111111111111111111111111111 I
#19000
11
